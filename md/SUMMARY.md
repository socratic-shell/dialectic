# Summary

<!-- Claude: consult chapters in this file for deeper background on topics as needed -->

- [Introduction](./introduction.md) <!-- ðŸ’¡: Project overview, problem statement, and relationship to socratic shell ecosystem -->

# User Guide <!-- ðŸ’¡: End-user documentation for people using Dialectic in their AI development workflow -->

- [Installation](./installation.md) <!-- ðŸ’¡: Step-by-step setup for both VSCode extension and MCP server components -->
- [Quick start](./quick-start.md) <!-- ðŸ’¡: Basic workflow example showing AI assistant â†’ review display â†’ navigation cycle -->
- [Features]() <!-- ðŸ’¡: Explains how to use each feature -->
    - [Code walkthroughs and Ask Socratic Shell](./walkthroughs.md) <!-- ðŸ’¡: Give examples of how to ask the agent to walk through code with you, what happens when you click links, and how you can use Ask Socratic Shell. -->
    - [Synthetic Pull Requests](./synthetic-pr.md) <!-- ðŸ’¡: How to create PR-like reviews from LLM code changes, with AI insight comments (ðŸ’¡â“TODO/FIXME) and familiar review workflows for approving/requesting changes -->
    - [IDE Capabilities](./ide-capabilities.md) <!-- ðŸ’¡: Natural language interface to VSCode/LSP features, current capabilities, and implementation details -->
    - [Review format](./review-format.md) <!-- ðŸ’¡: Explains file:line syntax, reference-style links [file:line][], and markdown conventions AI assistants should follow -->
- [Frequently asked questions](./faq.md) <!-- ðŸ’¡: Anticipated user questions about common errors, expected workflow, purpose, comparisons with other tools, etc -->

# Development and contribution guide <!-- ðŸ’¡: Technical documentation for contributors and people wanting to understand system internals -->

- [Building and testing](./design/build-and-test.md) <!-- ðŸ’¡: Development environment setup, build process, and testing procedures -->
- [System overview](./design/overview.md) <!-- ðŸ’¡: High-level architecture showing MCP server â†” VSCode extension communication via Unix sockets -->
    - [Communication protocol](./design/protocol.md) <!-- ðŸ’¡: JSON message format, Unix socket/named pipe IPC, and error handling between components -->
    - [Security considerations](./design/security.md) <!-- ðŸ’¡: CSP headers, DOMPurify sanitization, and secure webview practices for markdown rendering -->
    - [AI Guidance design considerations](./design/ai-guidance.md) <!-- ðŸ’¡: Design decisions made specifically to work well with AI collaboration patterns from socratic shell -->
    - [Codebase structure](./design/codebase-structure.md) <!-- ðŸ’¡: Overview of project structure, key files, and how components connect for contributors -->
- [How each feature works]() <!-- ðŸ’¡: Walk through the flow of particular features -->
    - [Code walkthroughs](./design/code-walkthroughs.md)
    - [Synthetic Pull Requests](./design/synthetic-pr.md) <!-- ðŸ’¡: Git operations with git2, AI comment parsing (ðŸ’¡â“TODO/FIXME), MCP tool implementation, and VSCode CommentController integration for PR-like workflows -->
    - [Ask Socratic Shell](./design/ask-socratic-shell.md) <!-- ðŸ’¡: How Ask Socratic Shell works, message flows, and implementation details -->
    - [IDE Capabilities](./design/ide-capabilities.md) <!-- ðŸ’¡: Natural language interface to VSCode/LSP features, current capabilities, and implementation details -->
- [MCP server](./design/mcp-server.md) <!-- ðŸ’¡: Highlights of the MCP server  --> 
    - [Daemon message bus](./design/daemon.md) <!-- ðŸ’¡: Central message router implementation, client management, process lifecycle, and Unix socket server architecture -->
    - [MCP Tool interface](./design/mcp-tool-interface.md) <!-- ðŸ’¡: API specification for AI assistants calling present_review tool with markdown content -->
- [VSCode extension](./design/extension.md) <!-- ðŸ’¡: Highlights of the VSCode Extension design and implementation: activation, establishing IPC protocol -->
- [Dialect language](./design/dialect-language.md) <!-- ðŸ’¡: JSON mini-language semantics for IDE operations - function composition, value types, and execution model -->


# References

- [Research reports]() <!-- ðŸ’¡: Background research that informed design decisions - consult when discussing related technical topics -->
    - [Markdown to HTML in VSCode Extensions](./references/markdown-to-html-in-vscode.md) <!-- ðŸ’¡: Comprehensive guide on markdown-it dominance (95% of VSCode extensions), custom renderer rules for link handling, multi-layered approach (parser/webview/extension), security with CSP and DOMPurify, command URI patterns. Relevant for: markdown processing, custom link handling, webview security, VSCode extension patterns -->
    - [VSCode Extension Communication Patterns](./references/cli-extension-communication-guide.md) <!-- ðŸ’¡: Four communication approaches between CLI tools and VSCode extensions: Unix socket/named pipe (recommended), HTTP server, file-based, and remote execution considerations. Covers environmentVariableCollection for discovery, cross-platform compatibility, security best practices. Relevant for: MCP server communication, IPC implementation, CLI-extension integration -->
    - [VSCode Sidebar Panel Research](./references/vscode-extensions-sidebar-panel-research-report.md) <!-- ðŸ’¡: Complete guide for VSCode extension sidebar panels including TreeDataProvider registration, package.json configuration, debugging strategies. Covers TreeView vs Webview approaches for content display, common configuration issues, and systematic debugging steps. Relevant for: sidebar UI implementation, extension architecture, TreeView/Webview decisions -->
    - [Language Server Protocol Overview](./references/lsp-overview/README.md) <!-- ðŸ’¡: LSP architecture solving MÃ—N complexity problem with client-server model, JSON-RPC 2.0 messaging, multiple transport options (stdio, sockets, TCP, Node.js IPC). Reduces editorÃ—language integrations from MÃ—N to M+N. Relevant for: protocol design patterns, client-server communication, future LSP integration considerations -->
        - [Base Protocol](./references/lsp-overview/base-protocol.md) <!-- ðŸ’¡: JSON-RPC 2.0 foundation with HTTP-style headers, Content-Length mandatory for stream communication, request/response/notification model with id correlation, standard and LSP-specific error codes. Relevant for: protocol design, message structure, error handling patterns -->
        - [Language Features](./references/lsp-overview/language-features.md) <!-- ðŸ’¡: Comprehensive LSP feature catalog including navigation (go-to-definition, find references), information (hover, signature help), code intelligence (completion, actions, lens), formatting, semantic tokens, inlay hints, and diagnostics (push/pull models). Relevant for: code intelligence features, enhanced review experience, future LSP integration -->
        - [Implementation Guide](./references/lsp-overview/implementation-guide.md) <!-- ðŸ’¡: Practical LSP server/client implementation patterns covering process isolation, message ordering, state management, error handling with exponential backoff, transport configuration (--stdio, --pipe, --socket), three-tier testing strategy, and security considerations (input validation, process isolation, path sanitization). Relevant for: robust IPC implementation, testing strategy, security best practices -->
        - [Message Reference](./references/lsp-overview/message-reference.md) <!-- ðŸ’¡: Complete LSP message catalog with request/response pairs, notifications, $/prefixed protocol messages, capabilities exchange during initialization, document synchronization (full/incremental), workspace/window features, and proper lifecycle management (initialize â†’ initialized â†’ shutdown â†’ exit). Relevant for: protocol patterns, capability negotiation, document synchronization, future LSP integration -->
    - [Unix IPC Message Bus Implementation Guide](./references/unix-message-bus-architecture.md) <!-- ðŸ’¡: Comprehensive research on Unix IPC message bus patterns covering Unix domain sockets vs other mechanisms, hub-and-spoke architecture with central broker, epoll-based event handling, process lifecycle management, performance optimization through hybrid approaches, security hardening, and real-world implementations (D-Bus, Redis, nanomsg). Validates Unix sockets as superior foundation for multi-client message buses with concrete implementation patterns. Relevant for: message bus daemon design, IPC architecture decisions, multi-process communication, performance considerations -->
    - [VSCode PR Extension Research](./references/vscode-extensions-dev-pattern.md) <!-- ðŸ’¡: This research report provides comprehensive technical documentation for building a VS Code extension that creates synthetic pull requests for LLM-generated code changes, covering all essential VS Code Extension APIs with detailed implementation examples. It includes the Comment Controller API for creating PR-like commenting experiences with pre-populated LLM explanations, the Tree View API for PR navigation interfaces in VS Code's sidebar, the Webview API for detailed PR panels with approve/request changes functionality, diff viewer integration for showing file changes, and file system watchers for detecting LLM modifications. The report contains practical code examples for comment thread management, tree data providers, webview panel creation, change tracking systems, command registration for review actions, and integration patterns for forwarding user feedback to LLMs and applying their suggested changes back to the codebase. Consult this report when implementing VS Code extensions that need to display code diffs, manage commenting workflows, create custom sidebar views, integrate with LLM APIs for code review scenarios, or replicate GitHub-style pull request interfaces within VS Code. -->
    - [VSCode File System Watching APIs](./references/VS-Code-file-system-watching.md) <!-- This comprehensive guide covers VS Code's file system watching capabilities for extension developers, including the workspace.createFileSystemWatcher() API, platform-specific implementations (Linux inotify, Windows ReadDirectoryChangesW, macOS FSEvents), performance optimization strategies, and handling external file changes that occur outside VS Code. It provides detailed implementation patterns for debouncing rapid changes, monitoring configuration files, handling race conditions and temporary files, optimizing glob patterns and exclusion rules, and working with remote development environments (WSL, SSH, containers, Codespaces). Consult this guide when building VS Code extensions that need to monitor file system changes, detect external modifications, optimize watching performance, handle cross-platform file events, implement change tracking systems, or work with file watching in remote development scenarios. -->
    - [Synthetic PRs in VSCode](./references/Synthetic-PRs-in-vscode.md) <!-- This research report provides comprehensive technical guidance for building synthetic/local pull request systems in VS Code that work entirely with local data without requiring remote Git repositories. It covers the CommentController API for code review interfaces, Git Extension API for local repository access, Source Control API integration, custom diff generation, state persistence strategies, and user interaction patterns that mirror traditional PR workflows. The report includes implementation examples from GitHub, Azure DevOps, and GitLab extensions, architectural recommendations for PR lifecycle management, and specific patterns for creating "fake" PRs from local Git changes, AI-generated code, or working directory modifications. Consult this report when building VS Code extensions that need local code review capabilities, synthetic PR interfaces, comment systems for line-by-line feedback, Git integration without remotes, AI code review workflows, or custom diff viewing experiences that don't rely on external PR providers. -->
    - [VSCode Git Extension API Capabilities](./references/VSCode-Git-Extension-API-capabilities.md) <!-- ðŸ’¡: Comprehensive analysis of VSCode's Git Extension API limitations and capabilities for synthetic PR implementation. Documents that the API lacks commit range parsing (HEAD~2..HEAD), structured file change data with statistics, multi-file PR review interfaces, and arbitrary commit diff generation. Validates the architectural decision to use custom Git operations (git2) for complex diff generation while leveraging VSCode APIs for UI integration. Includes detailed API method analysis and production extension patterns. Relevant for: Git integration decisions, API capability assessment, hybrid architecture validation -->
    - [Comment System Architecture for PR Reviews](./references/comment-system-on-pr.md) <!-- ðŸ’¡: Definitive architectural analysis for implementing GitHub-style PR comment systems in VSCode extensions. Covers CommentController API as the only viable choice (vs deprecated alternatives), DiffEditor integration for native file comparison, strategic webview enhancement for AI-specific features, and hybrid approach balancing native integration with AI conversation flexibility. Includes complete implementation patterns, phase-by-phase development strategy, and architectural trade-offs. Relevant for: comment system implementation, PR review UI, AI-human conversation interfaces, VSCode native integration -->
    - [Diff Visualization Strategies](./references/diff-visualization.md) <!-- ðŸ’¡: Research on diff visualization approaches for VSCode extensions covering native DiffEditor integration, custom diff rendering, syntax highlighting preservation, and performance considerations. Analyzes trade-offs between VSCode's built-in diff capabilities vs custom implementations for AI-generated code reviews. Includes implementation patterns for GitHub-style diff display and line-by-line commenting integration. Relevant for: diff display implementation, syntax highlighting, performance optimization, visual diff design -->
    - [Cumulative Diff Visualization Analysis](./references/diff-visualization-cumulative.md) <!-- ðŸ’¡: Extended analysis of diff visualization patterns specifically for cumulative/multi-file changes in synthetic PR contexts. Covers strategies for displaying related changes across multiple files, maintaining context between file diffs, and optimizing performance for large changesets. Includes patterns from production extensions and recommendations for AI-generated code review workflows. Relevant for: multi-file diff display, performance optimization, cumulative change visualization -->
    - [Copilot Integration Guide](./references/copilot-guide.md) <!-- ðŸ’¡: Analysis of GitHub Copilot's VSCode integration patterns for AI-assisted development workflows. Covers comment-based AI interaction, inline suggestion systems, and integration with existing VSCode features. Provides insights for building complementary AI tools that work alongside Copilot. Relevant for: AI integration patterns, comment-based workflows, VSCode AI tool ecosystem -->
    - [Copilot Integration Guide 2](./references/copilot-guide-2.md) <!-- ðŸ’¡: Extended analysis of Copilot integration patterns focusing on advanced features like chat interfaces, context awareness, and multi-turn conversations. Covers architectural patterns for AI tools that need to maintain conversation state and integrate with VSCode's editing experience. Relevant for: AI chat interfaces, conversation state management, advanced AI integration -->
    - [Copilot Integration Guide 3](./references/copilot-guide-3.md) <!-- ðŸ’¡: Comprehensive guide for implementing GitHub PR-style commenting UI in VSCode extensions with multi-line comment support, clickable gutter icons, expanded comment threads, and "Make Code Suggestion" functionality. Covers CommentController API, CommentingRangeProvider implementation, and troubleshooting common issues like missing reply buttons. Based on analysis of GitHub PR extension patterns. Relevant for: comment UI implementation, multi-line commenting, suggestion workflows, GitHub PR-style interfaces -->
    - [VSCode Comments API Reply Button Implementation](./references/VSCode-Comments-API-Reply-Button.md) <!-- ðŸ’¡: Definitive technical guide for implementing working reply buttons and multi-line comments in VSCode extensions using the Comments API. Covers the complete implementation pattern including CommentingRangeProvider requirements, package.json menu contributions, command registration, and custom action buttons like "Make Suggestion". Includes minimal working examples and troubleshooting for common issues. Based on analysis of microsoft/vscode-pull-request-github extension. Relevant for: reply button functionality, multi-line comment selection, custom comment actions, Comments API implementation -->
- [Decision documents]()