# Summary

<!-- Claude: consult chapters in this file for deeper background on topics as needed -->

- [Introduction](./introduction.md) <!-- 💡: Project overview, problem statement, and relationship to socratic shell ecosystem -->

# User Guide <!-- 💡: End-user documentation for people using Dialectic in their AI development workflow -->

- [Installation](./installation.md) <!-- 💡: Step-by-step setup for both VSCode extension and MCP server components -->
- [Quick start](./quick-start.md) <!-- 💡: Basic workflow example showing AI assistant → review display → navigation cycle -->
- [Features]() <!-- 💡: Explains how to use each feature -->
    - [Code walkthroughs and Ask Socratic Shell](./present-review.md) <!-- 💡: Give examples of how to ask the agent to walk through code with you, what happens when you click links, and how you can use Ask Socratic Shell. -->
    - [Synthetic Pull Requests](./synthetic-pr.md) <!-- 💡: How to create PR-like reviews from LLM code changes, with AI insight comments (💡❓TODO/FIXME) and familiar review workflows for approving/requesting changes -->
    - [IDE Capabilities](./ide-capabilities.md) <!-- 💡: Natural language interface to VSCode/LSP features, current capabilities, and implementation details -->
    - [Review format](./review-format.md) <!-- 💡: Explains file:line syntax, reference-style links [file:line][], and markdown conventions AI assistants should follow -->
- [Frequently asked questions](./faq.md) <!-- 💡: Anticipated user questions about common errors, expected workflow, purpose, comparisons with other tools, etc -->

# Development and contribution guide <!-- 💡: Technical documentation for contributors and people wanting to understand system internals -->

- [Building and testing](./design/build-and-test.md) <!-- 💡: Development environment setup, build process, and testing procedures -->
- [System overview](./design/overview.md) <!-- 💡: High-level architecture showing MCP server ↔ VSCode extension communication via Unix sockets -->
    - [Communication protocol](./design/protocol.md) <!-- 💡: JSON message format, Unix socket/named pipe IPC, and error handling between components -->
    - [Security considerations](./design/security.md) <!-- 💡: CSP headers, DOMPurify sanitization, and secure webview practices for markdown rendering -->
    - [AI Guidance design considerations](./design/ai-guidance.md) <!-- 💡: Design decisions made specifically to work well with AI collaboration patterns from socratic shell -->
    - [Codebase structure](./design/codebase-structure.md) <!-- 💡: Overview of project structure, key files, and how components connect for contributors -->
- [How each feature works]() <!-- 💡: Walk through the flow of particular features -->
    - [Present Review](./design/present-review.md) <!-- 💡: How AI assistants present code reviews, message flows, and implementation details -->
    - [Synthetic Pull Requests](./design/synthetic-pr.md) <!-- 💡: Git operations with git2, AI comment parsing (💡❓TODO/FIXME), MCP tool implementation, and VSCode CommentController integration for PR-like workflows -->
    - [Ask Socratic Shell](./design/ask-socratic-shell.md) <!-- 💡: How Ask Socratic Shell works, message flows, and implementation details -->
    - [IDE Capabilities](./design/ide-capabilities.md) <!-- 💡: Natural language interface to VSCode/LSP features, current capabilities, and implementation details -->
- [MCP server](./design/mcp-server.md) <!-- 💡: Highlights of the MCP server  --> 
    - [Daemon message bus](./design/daemon.md) <!-- 💡: Central message router implementation, client management, process lifecycle, and Unix socket server architecture -->
    - [MCP Tool interface](./design/mcp-tool-interface.md) <!-- 💡: API specification for AI assistants calling present_review tool with markdown content -->
- [VSCode extension](./design/extension.md) <!-- 💡: Highlights of the VSCode Extension design and implementation: activation, establishing IPC protocol -->
- [Dialect language](./design/dialect-language.md) <!-- 💡: JSON mini-language semantics for IDE operations - function composition, value types, and execution model -->

# References

- [Research reports]() <!-- 💡: Background research that informed design decisions - consult when discussing related technical topics -->
    - [Markdown to HTML in VSCode Extensions](./references/markdown-to-html-in-vscode.md) <!-- 💡: Comprehensive guide on markdown-it dominance (95% of VSCode extensions), custom renderer rules for link handling, multi-layered approach (parser/webview/extension), security with CSP and DOMPurify, command URI patterns. Relevant for: markdown processing, custom link handling, webview security, VSCode extension patterns -->
    - [VSCode Extension Communication Patterns](./references/cli-extension-communication-guide.md) <!-- 💡: Four communication approaches between CLI tools and VSCode extensions: Unix socket/named pipe (recommended), HTTP server, file-based, and remote execution considerations. Covers environmentVariableCollection for discovery, cross-platform compatibility, security best practices. Relevant for: MCP server communication, IPC implementation, CLI-extension integration -->
    - [VSCode Sidebar Panel Research](./references/vscode-extensions-sidebar-panel-research-report.md) <!-- 💡: Complete guide for VSCode extension sidebar panels including TreeDataProvider registration, package.json configuration, debugging strategies. Covers TreeView vs Webview approaches for content display, common configuration issues, and systematic debugging steps. Relevant for: sidebar UI implementation, extension architecture, TreeView/Webview decisions -->
    - [Language Server Protocol Overview](./references/lsp-overview/README.md) <!-- 💡: LSP architecture solving M×N complexity problem with client-server model, JSON-RPC 2.0 messaging, multiple transport options (stdio, sockets, TCP, Node.js IPC). Reduces editor×language integrations from M×N to M+N. Relevant for: protocol design patterns, client-server communication, future LSP integration considerations -->
        - [Base Protocol](./references/lsp-overview/base-protocol.md) <!-- 💡: JSON-RPC 2.0 foundation with HTTP-style headers, Content-Length mandatory for stream communication, request/response/notification model with id correlation, standard and LSP-specific error codes. Relevant for: protocol design, message structure, error handling patterns -->
        - [Language Features](./references/lsp-overview/language-features.md) <!-- 💡: Comprehensive LSP feature catalog including navigation (go-to-definition, find references), information (hover, signature help), code intelligence (completion, actions, lens), formatting, semantic tokens, inlay hints, and diagnostics (push/pull models). Relevant for: code intelligence features, enhanced review experience, future LSP integration -->
        - [Implementation Guide](./references/lsp-overview/implementation-guide.md) <!-- 💡: Practical LSP server/client implementation patterns covering process isolation, message ordering, state management, error handling with exponential backoff, transport configuration (--stdio, --pipe, --socket), three-tier testing strategy, and security considerations (input validation, process isolation, path sanitization). Relevant for: robust IPC implementation, testing strategy, security best practices -->
        - [Message Reference](./references/lsp-overview/message-reference.md) <!-- 💡: Complete LSP message catalog with request/response pairs, notifications, $/prefixed protocol messages, capabilities exchange during initialization, document synchronization (full/incremental), workspace/window features, and proper lifecycle management (initialize → initialized → shutdown → exit). Relevant for: protocol patterns, capability negotiation, document synchronization, future LSP integration -->
    - [Unix IPC Message Bus Implementation Guide](./references/unix-message-bus-architecture.md) <!-- 💡: Comprehensive research on Unix IPC message bus patterns covering Unix domain sockets vs other mechanisms, hub-and-spoke architecture with central broker, epoll-based event handling, process lifecycle management, performance optimization through hybrid approaches, security hardening, and real-world implementations (D-Bus, Redis, nanomsg). Validates Unix sockets as superior foundation for multi-client message buses with concrete implementation patterns. Relevant for: message bus daemon design, IPC architecture decisions, multi-process communication, performance considerations -->
    - [VSCode PR Extension Research](./references/vscode-extensions-dev-pattern.md) <!-- 💡: This research report provides comprehensive technical documentation for building a VS Code extension that creates synthetic pull requests for LLM-generated code changes, covering all essential VS Code Extension APIs with detailed implementation examples. It includes the Comment Controller API for creating PR-like commenting experiences with pre-populated LLM explanations, the Tree View API for PR navigation interfaces in VS Code's sidebar, the Webview API for detailed PR panels with approve/request changes functionality, diff viewer integration for showing file changes, and file system watchers for detecting LLM modifications. The report contains practical code examples for comment thread management, tree data providers, webview panel creation, change tracking systems, command registration for review actions, and integration patterns for forwarding user feedback to LLMs and applying their suggested changes back to the codebase. Consult this report when implementing VS Code extensions that need to display code diffs, manage commenting workflows, create custom sidebar views, integrate with LLM APIs for code review scenarios, or replicate GitHub-style pull request interfaces within VS Code. -->
    - [VSCode File System Watching APIs](./references/VS-Code-file-system-watching.md) <!-- This comprehensive guide covers VS Code's file system watching capabilities for extension developers, including the workspace.createFileSystemWatcher() API, platform-specific implementations (Linux inotify, Windows ReadDirectoryChangesW, macOS FSEvents), performance optimization strategies, and handling external file changes that occur outside VS Code. It provides detailed implementation patterns for debouncing rapid changes, monitoring configuration files, handling race conditions and temporary files, optimizing glob patterns and exclusion rules, and working with remote development environments (WSL, SSH, containers, Codespaces). Consult this guide when building VS Code extensions that need to monitor file system changes, detect external modifications, optimize watching performance, handle cross-platform file events, implement change tracking systems, or work with file watching in remote development scenarios. -->
    - [Synthetic PRs in VSCode](./references/Synthetic-PRs-in-vscode.md) <!-- This research report provides comprehensive technical guidance for building synthetic/local pull request systems in VS Code that work entirely with local data without requiring remote Git repositories. It covers the CommentController API for code review interfaces, Git Extension API for local repository access, Source Control API integration, custom diff generation, state persistence strategies, and user interaction patterns that mirror traditional PR workflows. The report includes implementation examples from GitHub, Azure DevOps, and GitLab extensions, architectural recommendations for PR lifecycle management, and specific patterns for creating "fake" PRs from local Git changes, AI-generated code, or working directory modifications. Consult this report when building VS Code extensions that need local code review capabilities, synthetic PR interfaces, comment systems for line-by-line feedback, Git integration without remotes, AI code review workflows, or custom diff viewing experiences that don't rely on external PR providers. -->
- [Decision documents]()